# Exception Hierarchy

<!-- TOC -->

- [1. Checked Exceptions](#1-checked-exceptions)
- [2. Unchecked Exceptions](#2-unchecked-exceptions)
- [3. Errors](#3-errors)

<!-- /TOC -->

## 1. Checked Exceptions

Checked Exceptions are the exceptions that we can typically foresee and plan ahead in our application. These are also exceptions that the Java Compiler requires us to either **handle-or-declare** when writing code.

The **handle-or-declare** rule refers to our responsibility to either **declare that a method throws an exception up the call stack** - without doing much to prevent it or **handle the exception with our own code**, which typically leads to the recovery of the program from the exceptional condition.

This is the reason why they're called **checked exceptions**. The compiler can detect them before runtime, and you're aware of their potential existence while writing code.

## 2. Unchecked Exceptions

Unchecked Exceptions are the exceptions that typically occur due to human, rather than an environmental error. These exceptions are not checked during compile-time, but at runtime, which is the reason they're also called **Runtime Exceptions**.

They can often be countered by implementing **simple checks** before a segment of code that could potentially be used in a way that forms a runtime exception.<sub>处理Exception的最好的办法就是：写代码，要事前多检查，避免事后出异常</sub>

## 3. Errors

Errors are the most serious exceptional conditions that you can run into. They are often irrecoverable from and there's no real way to handle them. The only thing we, as developers, can do is optimize the code in hopes that the errors never occur.

Errors can occur due to human and environmental errors. Creating an infinitely recurring method can lead to a `StackOverflowError`, or a memory leak can lead to an `OutOfMemoryError`.
