# 理解Class文件的存储结构

最开始，就说明目标：要理解一张表。

每个视频开始的部分，都要讲一个当前到什么章节了，就像海贼王的开头一样。

<!-- TOC -->

- [1. 第一层：炸死TA搜搜](#1-%E7%AC%AC%E4%B8%80%E5%B1%82%E7%82%B8%E6%AD%BBta%E6%90%9C%E6%90%9C)
  - [1.1. Magic Number](#11-magic-number)
  - [1.2. Class Version](#12-class-version)
- [2. 第二层：胆大心细，亦不过如此](#2-%E7%AC%AC%E4%BA%8C%E5%B1%82%E8%83%86%E5%A4%A7%E5%BF%83%E7%BB%86%E4%BA%A6%E4%B8%8D%E8%BF%87%E5%A6%82%E6%AD%A4)
  - [2.1. constant_pool_count](#21-constantpoolcount)
  - [2.2. Constant Pool](#22-constant-pool)
    - [2.2.1. CONSTANT_Utf8_info](#221-constantutf8info)
    - [2.2.2. CONSTANT_Integer_info](#222-constantintegerinfo)
    - [2.2.3. CONSTANT_Float_info](#223-constantfloatinfo)
    - [2.2.4. CONSTANT_Long_info](#224-constantlonginfo)
    - [2.2.5. CONSTANT_Double_info](#225-constantdoubleinfo)
    - [2.2.6. CONSTANT_Class_info](#226-constantclassinfo)
    - [2.2.7. CONSTANT_String_info](#227-constantstringinfo)
    - [2.2.8. CONSTANT_Fieldref_info](#228-constantfieldrefinfo)
    - [2.2.9. CONSTANT_Methodref_info](#229-constantmethodrefinfo)
    - [2.2.10. CONSTANT_InterfaceMethodref_info](#2210-constantinterfacemethodrefinfo)
    - [2.2.11. CONSTANT_NameAndType_info](#2211-constantnameandtypeinfo)
    - [2.2.12. CONSTANT_MethodHandle_info](#2212-constantmethodhandleinfo)
    - [2.2.13. CONSTANT_MethodType_info](#2213-constantmethodtypeinfo)
    - [2.2.14. CONSTANT_InvokeDynamic_info](#2214-constantinvokedynamicinfo)
- [3. 第三层：炸死TA搜搜again](#3-%E7%AC%AC%E4%B8%89%E5%B1%82%E7%82%B8%E6%AD%BBta%E6%90%9C%E6%90%9Cagain)
  - [3.1. Access Flags](#31-access-flags)
    - [3.1.1. ACC_SUPER](#311-accsuper)
    - [3.1.2. ACC_PUBLIC](#312-accpublic)
    - [3.1.3. ACC_ABSTRACT](#313-accabstract)
    - [3.1.4. ACC_INTERFACE](#314-accinterface)
    - [3.1.5. ACC_FINAL](#315-accfinal)
    - [3.1.6. ACC_ENUM](#316-accenum)
  - [3.2. This Class](#32-this-class)
  - [3.3. Super Class](#33-super-class)
  - [3.4. Interfaces](#34-interfaces)
- [4. 第四层：曾经沧海难为水](#4-%E7%AC%AC%E5%9B%9B%E5%B1%82%E6%9B%BE%E7%BB%8F%E6%B2%A7%E6%B5%B7%E9%9A%BE%E4%B8%BA%E6%B0%B4)
  - [4.1. Fields](#41-fields)
    - [4.1.1. fields_count](#411-fieldscount)
    - [4.1.2. fields_info](#412-fieldsinfo)
      - [4.1.2.1. `ACC_PUBLIC`～`ACC_TRANSIENT`](#4121-accpublicacctransient)
      - [4.1.2.2. Interface Fields: `ACC_PUBLIC`, `ACC_STATIC` 和 `ACC_FINAL`](#4122-interface-fields-accpublic-accstatic-%E5%92%8C-accfinal)
      - [4.1.2.3. ACC_SYNTHETIC](#4123-accsynthetic)
  - [4.2. Methods](#42-methods)
  - [4.3. Attributes](#43-attributes)
    - [4.3.1. Code属性](#431-code%E5%B1%9E%E6%80%A7)
    - [4.3.2. Exceptions属性](#432-exceptions%E5%B1%9E%E6%80%A7)
    - [4.3.3. LineNumberTable属性](#433-linenumbertable%E5%B1%9E%E6%80%A7)
    - [4.3.4. LocalVariableTable属性](#434-localvariabletable%E5%B1%9E%E6%80%A7)
    - [4.3.5. SourceFile属性](#435-sourcefile%E5%B1%9E%E6%80%A7)
    - [4.3.6. ConstantValue属性](#436-constantvalue%E5%B1%9E%E6%80%A7)
    - [4.3.7. InnerClasses属性](#437-innerclasses%E5%B1%9E%E6%80%A7)
    - [4.3.8. Deprecated及Synthetic属性](#438-deprecated%E5%8F%8Asynthetic%E5%B1%9E%E6%80%A7)
    - [4.3.9. StackMapTable属性](#439-stackmaptable%E5%B1%9E%E6%80%A7)
    - [4.3.10. Signature属性](#4310-signature%E5%B1%9E%E6%80%A7)
    - [4.3.11. BootstrapMethods属性](#4311-bootstrapmethods%E5%B1%9E%E6%80%A7)
- [5. Glossary](#5-glossary)
  - [5.1. access_flags对比：Class、Field、Method](#51-accessflags%E5%AF%B9%E6%AF%94classfieldmethod)
- [6. 不足之处](#6-%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84)

<!-- /TOC -->

`java_class_file_info`

讲解思路：当成一个人家，有“年代、仓库、房子、家具”组成。一户人家的庭院，建于20世纪80年代，有一个仓库（食物有米、面、油），一个房子，房子里有家具（桌子、凳子）。


| 数据结构         | 名称                  | 数量                      |
| ---------------- | --------------------- | ------------------------- |
| `u4`             | `magic_number`        | `1`                       |
| `u2`             | `minor_version`       | `1`                       |
| `u2`             | `major_version`       | 1                         |
| `u2`             | `constant_pool_count` | 1                         |
| `cp_info`        | `constant_pool`       | `constant_pool_count - 1` |
| `u2`             | `access_flags`        | `1`                       |
| `u2`             | `this_class`          | `1`                       |
| `u2`             | `super_class`         | `1`                       |
| `u2`             | `interfaces_count`    | `1`                       |
| `u2`             | `interfaces`          | `interfaces_count`        |
| `u2`             | `fields_count`        | `1`                       |
| `field_info`     | `fields`              | `fields_count`            |
| `u2`             | `methods_count`       | `1`                       |
| `method_info`    | `methods`             | `methods_count`           |
| `u2`             | `attributes_count`    | `1`                       |
| `attribute_info` | `attributes`          | `attributes_count`        |

《理解Class结构》，这门“武功”分成4个层次：

- 第一层：炸死TA搜搜（Just so-so）
- 第二层：胆大心细，亦不过如此
- 第三层：炸死TA搜搜again
- 第四层：曾经沧海难为水

第一层：炸死TA搜搜。这里只包括`magic_number`、`minor_version` 和 `major_version`三个，它们是`u2`、`u4`类型的数据，非常简单。

第二层：胆大心细，亦不过如此。这里只包括`constant_pool_count` 和 `constant_pool`，虽然涉及到的结构类型比较多，但本质上是简单的，只是处理复杂的问题时，需要有耐心和细心。

第三层：炸死TA搜搜again。这里包括`access_flags`、`this_class`、`super_class`、`interfaces_count` 和 `interfaces` 五个，它们都是`u2`类型的数据，也是非常简单的。

第四层：曾经沧海难为水。曾经到过沧海，看到别的河流也不足为顾了。见识过第二层的Constant Pool，这里的`fields_count`、`fields`、`methods_count`、`methods`、`attributes_count` 和 `attributes` 也就算不得什么了。

## 1. 第一层：炸死TA搜搜

```java
public class HelloWorld {
    //
}
```

```bash
$ javac -g HelloWorld.java
$ hexdump -C HelloWorld.class
00000000  ca fe ba be 00 00 00 34  00 10 0a 00 03 00 0d 07  |.......4........|
00000010  00 0e 07 00 0f 01 00 06  3c 69 6e 69 74 3e 01 00  |........<init>..|
00000020  03 28 29 56 01 00 04 43  6f 64 65 01 00 0f 4c 69  |.()V...Code...Li|
00000030  6e 65 4e 75 6d 62 65 72  54 61 62 6c 65 01 00 12  |neNumberTable...|
00000040  4c 6f 63 61 6c 56 61 72  69 61 62 6c 65 54 61 62  |LocalVariableTab|
00000050  6c 65 01 00 04 74 68 69  73 01 00 0c 4c 48 65 6c  |le...this...LHel|
00000060  6c 6f 57 6f 72 6c 64 3b  01 00 0a 53 6f 75 72 63  |loWorld;...Sourc|
00000070  65 46 69 6c 65 01 00 0f  48 65 6c 6c 6f 57 6f 72  |eFile...HelloWor|
00000080  6c 64 2e 6a 61 76 61 0c  00 04 00 05 01 00 0a 48  |ld.java........H|
00000090  65 6c 6c 6f 57 6f 72 6c  64 01 00 10 6a 61 76 61  |elloWorld...java|
000000a0  2f 6c 61 6e 67 2f 4f 62  6a 65 63 74 00 21 00 02  |/lang/Object.!..|
000000b0  00 03 00 00 00 00 00 01  00 01 00 04 00 05 00 01  |................|
000000c0  00 06 00 00 00 2f 00 01  00 01 00 00 00 05 2a b7  |...../........*.|
000000d0  00 01 b1 00 00 00 02 00  07 00 00 00 06 00 01 00  |................|
000000e0  00 00 01 00 08 00 00 00  0c 00 01 00 00 00 05 00  |................|
000000f0  09 00 0a 00 00 00 01 00  0b 00 00 00 02 00 0c     |...............|

```

### 1.1. Magic Number

本节讲解：`magic_number`

| 数据结构         | 名称                  | 数量                      |
| ---------------- | --------------------- | ------------------------- |
| `u4`             | `magic_number`        | `1`                       |
| `u2`             | `minor_version`       | `1`                       |

每个`.class`文件的头4个字节称为魔数(Magic Number)，它唯一的作用是确定这个文件是否为一个能被虚拟机接受的Class文件。

Class文件的魔数很有“玩乐”的意味，值为：`0xCAFEBABE`。据Java开发小组最初的关键成员Patrick Naughton所说：“我们一直在寻找一些好玩的、容易记忆的东西，选择`0xCAFEBABE`是因为它象征着著名咖啡品牌Peet's Coffee中深受欢迎的Baristas咖啡”。

> 搜索一下，这句话（Patrick Naughton）的英文版  
> 搜索一下Baristas咖啡是一个什么样的受欢迎地位

![magic-number](images/helloworld-magic-number.png)

### 1.2. Class Version

本节讲解：`minor_version` 和 `major_version`

| 数据结构         | 名称                  | 数量                      |
| ---------------- | --------------------- | ------------------------- |
| `u4`             | `magic_number`        | `1`                       |
| `u2`             | `minor_version`       | `1`                       |
| `u2`             | `major_version`       | 1                         |
| `u2`             | `constant_pool_count` | 1                         |

第5和第6个字节是次版本号(Minor Version)，第7和第8个字节是主版本号(Major Version)。

在下图中，Minor Version的值是`0x0000`，换成十进制为`0`；Major Version的值为`0034`，换成十进制为`52`。

![minor-major-version](images/helloworld-minor-major-version.png)

Java的主版本(Major Version)是从45开始，JDK 1.1之后的每个JDK大版本发布主版本号向上加1（JDK 1.0~1.1使用了45.0~45.3的版本号）。

Class文件版本号如下：

| 十六进制版本号 | 十进制版本号 | 编译器版本 |
| -------------- | ------------ | ---------- |
| `00 00 00 34`  | `52.0`       | `JDK 1.8`  |
| `00 00 00 33`  | `51.0`       | `JDK 1.7`  |
| `00 00 00 32`  | `50.0`       | `JDK 1.6`  |
| `00 00 00 31`  | `49.0`       | `JDK 1.5`  |
| `00 00 00 30`  | `48.0`       | `JDK 1.4`  |
| `00 00 00 2F`  | `47.0`       | `JDK 1.3`  |
| `00 00 00 2E`  | `46.0`       | `JDK 1.2`  |
| `00 00 00 2D`  | `45.0`       | `JDK 1.1`  |

高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后的Class文件，即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。

```java
import lsieun.utils.IOUtils;

public class ModifyClass {
    public static void main(String[] args) {
        String filepath = "HelloWorld.class";
        byte[] bytes = IOUtils.readBytes(filepath);

        bytes[7] = 53;
        IOUtils.writeBytes(filepath, bytes);
    }
}
```

## 2. 第二层：胆大心细，亦不过如此

本节讲解：`constant_pool_count` 和 `constant_pool`

| 数据结构         | 名称                  | 数量                      |
| ---------------- | --------------------- | ------------------------- |
| `u2`             | `major_version`       | 1                         |
| `u2`             | `constant_pool_count` | 1                         |
| `cp_info`        | `constant_pool`       | `constant_pool_count - 1` |
| `u2`             | `access_flags`        | `1`                       |

### 2.1. constant_pool_count

`constant_pool_count`，代表常量池中常量计数值。

```java
public class HelloWorld {
    //
}
```

```bash
# 编译
$ javac -g HelloWorld.java
# 查看十六进制
$ hexdump -C HelloWorld.class
# 查看常量池的内容
$ javap -v HelloWorld.class
```

在下图中，是使用`javac -g HelloWorld.java`生成的结果，常量池容量为十六进制数`0x0010`，换成十进制为`16`。

> 注意：如果使用`javac HelloWorld.java`，常量池容量为十六进制数`0x000d`，换成十进制为`13`。

![constant-pool-count](images/helloworld-constant-pool-count.png)

使用`javap -v HelloWorld.class`，可以查看到有`15`个常量，索引值范围为`1~15`。在Class文件格式规范制定之时，设计者将第`0`项常量空出来是有特殊考虑的，这样做的目的在于满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况就可以把索引位置设置为`0`来表示。`0`和`1~15`一共记为`16`个常量，常量索引`0`是不可见的、不需要存储的，而`1~15`是可见的、需要存储的。

```txt
Constant pool:
   #1 = Methodref          #3.#13         // java/lang/Object."<init>":()V
   #2 = Class              #14            // HelloWorld
   #3 = Class              #15            // java/lang/Object
   #4 = Utf8               <init>
   #5 = Utf8               ()V
   #6 = Utf8               Code
   #7 = Utf8               LineNumberTable
   #8 = Utf8               LocalVariableTable
   #9 = Utf8               this
  #10 = Utf8               LHelloWorld;
  #11 = Utf8               SourceFile
  #12 = Utf8               HelloWorld.java
  #13 = NameAndType        #4:#5          // "<init>":()V
  #14 = Utf8               HelloWorld
  #15 = Utf8               java/lang/Object
```

### 2.2. Constant Pool

| 数据结构         | 名称                  | 数量                      |
| ---------------- | --------------------- | ------------------------- |
| `u2`             | `constant_pool_count` | 1                         |
| `cp_info`        | `constant_pool`       | `constant_pool_count - 1` |
| `u2`             | `access_flags`        | `1`                       |

`cp_info`并不是一个具体的存储结构，而是多个存储结构的名称集合。当前，`cp_info`包括14种具体的存储结构。这14种表有一个共同特点，就是存储结构开始的第一位是`u1`类型的标志位`tag`，用于区分当前的`cp_info`是属于哪一种具体的存储结构。

| 数据结构   | 名称        | 数量          |
| ---------| -----------| --------------|
| `u1`     | `tag`      | 1             |

常量池`cp_info`使用`tag`区分具体类型的存储结构如下：

| 标志位tag | 存储结构类型                       | 描述                     |
| --------- | ---------------------------------- | ------------------------ |
| `1`       | `CONSTANT_Utf8_info`               | UTF-8编码的字符串        |
| `3`       | `CONSTANT_Integer_info`            | 整型字面量               |
| `4`       | `CONSTANT_Float_info`              | 浮点型字面量             |
| `5`       | `CONSTANT_Long_info`               | 长整型字面量             |
| `6`       | `CONSTANT_Double_info`             | 双精度浮点型字面量       |
| `7`       | `CONSTANT_Class_info`              | 类或接口的符号引用       |
| `8`       | `CONSTANT_String_info`             | 字符串类型符号引用       |
| `9`       | `CONSTNAT_Fieldref_info`           | 类中字段的符号引用       |
| `10`      | `CONSTANT_Methodref_info`          | 类中方法的符号引用       |
| `11`      | `CONSTANT_InterfaceMethodref_info` | 接口中方法的符号引用     |
| `12`      | `CONSTANT_NameAndType_info`        | 字段或方法的部分符号引用 |
| `15`      | `CONSTANT_MethodHandle_info`       | 表示方法句柄             |
| `16`      | `CONSTANT_MethodType_info`         | 表示方法类型             |
| `18`      | `CONSTANT_InvokeDynamic_info`      | 表示一个动态方法调用点   |

常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。

- [ ] 常量
  - [ ] 字面量
    - [ ] 文本字符串
    - [ ] 声明为final的常量值
  - [ ] 符号引用
    - [ ] 类和接口的全限定名（Fully Qualified Name）
    - [ ] 字段的名称和描述（Descriptor）
    - [ ] 方法的名称和描述（Descriptor）

#### 2.2.1. CONSTANT_Utf8_info

| 存储结构 | 名称     | 描述                                |
| -------- | -------- | ----------------------------------- |
| `u1`     | `tag`    | 值为`1`                             |
| `u2`     | `length` | `UTF-8`编码的字符串占用的字节数     |
| `u1`     | `bytes`  | 长度为`length`的`UTF-8`编码的字符串 |

举例如下：

```txt
UTF8: {value='HelloWorld', pattern='tag(2)-length(4)-info', hexCode='01000A48656C6C6F576F726C64'}
UTF8: {value='java/lang/Object', pattern='tag(2)-length(4)-info', hexCode='0100106A6176612F6C616E672F4F626A656374'}
```

#### 2.2.2. CONSTANT_Integer_info

| 存储结构 | 名称    | 描述                    |
| -------- | ------- | ----------------------- |
| `u1`     | `tag`   | 值为`3`                 |
| `u4`     | `bytes` | 按照高位在前存储的int值 |

```java
public class HelloWorld {
    private final int value = 1041;
}
```

```txt
Integer: {intValue=1041, pattern='tag(2)-bytes(8)', hexCode='0300000411'}
```

#### 2.2.3. CONSTANT_Float_info

| 存储结构 | 名称    | 描述                    |
| -------- | ------- | ----------------------- |
| `u1`     | `tag`   | 值为`4`                 |
| `u4`     | `bytes` | 按照高位在前存储的float值 |

```java
public class HelloWorld {
    private final float value = 3.14F;
}
```

```txt
Float: {floatValue=3.14, pattern='tag(2)-bytes(8)', hexCode='044048F5C3'}
```

#### 2.2.4. CONSTANT_Long_info

| 存储结构 | 名称    | 描述                    |
| -------- | ------- | ----------------------- |
| `u1`     | `tag`   | 值为`5`                 |
| `u8`     | `bytes` | 按照高位在前存储的long值 |

注意：`CONSTANT_Long_info` 和 `CONSTANT_Double_info` 的位序是占2个的。

```java
public class HelloWorld {
    private final float value = 3.14F;
}
```

```txt
Long: {longValue=100, pattern='tag(2)-bytes(16)', hexCode='050000000000000064'}
```

#### 2.2.5. CONSTANT_Double_info

| 存储结构 | 名称    | 描述                    |
| -------- | ------- | ----------------------- |
| `u1`     | `tag`   | 值为`6`                 |
| `u8`     | `bytes` | 按照高位在前存储的double值 |

注意：`CONSTANT_Long_info` 和 `CONSTANT_Double_info` 的位序是占2个的。

```java
public class HelloWorld {
    private final double value = 0.72;
}
```

```txt
Double: {doubleValue=0.72, pattern='tag(2)-bytes(16)', hexCode='063FE70A3D70A3D70A'}
```

#### 2.2.6. CONSTANT_Class_info

| 存储结构 | 名称    | 描述                    |
| -------- | ------- | ----------------------- |
| `u1`     | `tag`   | 值为`7`                 |
| `u2`     | `index` | 指向全限定名常量项的索引 |

```txt
|005| CLASS: {index=5, classIndex=18, value='HelloWorld', pattern='tag(2)-nameIndex(4)', hexCode='070012'}
|018| UTF8: {index=18, value='HelloWorld', pattern='tag(2)-length(4)-info', hexCode='01000A48656C6C6F576F726C64'}
```

#### 2.2.7. CONSTANT_String_info

| 存储结构 | 名称    | 描述                    |
| -------- | ------- | ----------------------- |
| `u1`     | `tag`   | 值为`8`                 |
| `u2`     | `index` | 指向字符串字面量的索引 |

```java
public class HelloWorld {
    private final String value = "abc";
}
```

```txt
|002| String: {index=2, stringIndex=16, value='abc', pattern='tag(2)-utf8Index(4)', hexCode='080010'}
|016| UTF8: {index=16, value='abc', pattern='tag(2)-length(4)-info', hexCode='010003616263'}
```

#### 2.2.8. CONSTANT_Fieldref_info

| 存储结构 | 名称    | 描述                    |
| -------- | ------- | ----------------------- |
| `u1`     | `tag`   | 值为`9`                 |
| `u2`     | `index` | 指向声明字段的类或接口描述符CONSTANT_Class_info的索引项 |
| `u2`     | `index` | 指向字段的名称及类型描述符CONSTANT_NameAndType_info的索引项 |

```java
public class HelloWorld {
    private String value;

    public void test() {
        // 或者赋值
        this.value = "abc";
        // 或者取值
        String str = this.value;
    }
}
```

注意：`Field Ref`记录的是字段的使用（取值 或 赋值），而并不是字段的定义(Field Definition)。

```txt
|003| Field Ref: {index=3, classIndex=4, nameAndTypeIndex=17, value='HelloWorld.value: Ljava/lang/String;', pattern='tag(2)-classIndex(4)-nameAndTypeIndex(4)', hexCode='0900040011'}
|004| CLASS: {index=4, classIndex=18, value='HelloWorld', pattern='tag(2)-nameIndex(4)', hexCode='070012'}
|017| Name And Type: {index=17, nameIndex=6, descriptorIndex=7, value='value: Ljava/lang/String;', pattern='tag(2)-nameIndex(4)-descriptorIndex(4)', hexCode='0C00060007'}
```

#### 2.2.9. CONSTANT_Methodref_info

| 存储结构 | 名称    | 描述                    |
| -------- | ------- | ----------------------- |
| `u1`     | `tag`   | 值为`10`                 |
| `u2`     | `index` | 指向声明方法的类或接口描述符CONSTANT_Class_info的索引项 |
| `u2`     | `index` | 指向方法的名称及类型描述符CONSTANT_NameAndType_info的索引项 |

```java
public class HelloWorld {
    public void print() {
        //
    }

    public void test() {
        this.print(); // Method Ref
    }
}
```

注意： `Method Ref`是记录方法的调用(Invoke Method)，而不是方法的定义(Method Definition)。方法的定义(Method Definition)是记录在`methods`那一部分，而当前是`constant_pool`部分。

```txt
|002| Method Ref: {index=2, classIndex=3, nameAndTypeIndex=14, value='HelloWorld.print: ()V', pattern='tag(2)-classIndex(4)-nameAndTypeIndex(4)', hexCode='0A0003000E'}
|003| CLASS: {index=3, classIndex=15, value='HelloWorld', pattern='tag(2)-nameIndex(4)', hexCode='07000F'}
|014| Name And Type: {index=14, nameIndex=9, descriptorIndex=6, value='print: ()V', pattern='tag(2)-nameIndex(4)-descriptorIndex(4)', hexCode='0C00090006'}
```

#### 2.2.10. CONSTANT_InterfaceMethodref_info

| 存储结构 | 名称    | 描述                    |
| -------- | ------- | ----------------------- |
| `u1`     | `tag`   | 值为`11`                 |
| `u2`     | `index` | 指向声明方法接口描述符CONSTANT_Class_info的索引项 |
| `u2`     | `index` | 指向方法的名称及类型描述符CONSTANT_NameAndType_info的索引项 |

#### 2.2.11. CONSTANT_NameAndType_info

| 存储结构 | 名称    | 描述                    |
| -------- | ------- | ----------------------- |
| `u1`     | `tag`   | 值为`12`                 |
| `u2`     | `index` | 指向该字段或方法名称常量项的索引 |
| `u2`     | `index` | 指向该字段或方法描述符常量项的索引项 |

```java
public class HelloWorld {
}
```

```txt
|010| Name And Type: {index=10, nameIndex=4, descriptorIndex=5, value='<init>: ()V', pattern='tag(2)-nameIndex(4)-descriptorIndex(4)', hexCode='0C00040005'}

|004| UTF8: {index=4, value='<init>', pattern='tag(2)-length(4)-info', hexCode='0100063C696E69743E'}
|005| UTF8: {index=5, value='()V', pattern='tag(2)-length(4)-info', hexCode='010003282956'}
```

#### 2.2.12. CONSTANT_MethodHandle_info

| 存储结构 | 名称    | 描述                    |
| -------- | ------- | ----------------------- |
| `u1`     | `tag`   | 值为`15`                 |
| `u1`     | `reference_kind` | 值必须在`1~9`之间（包括1和9），它决定了方法句柄的类型。方法句柄类型的值表示方法句柄的字节码行为。 |
| `u2`     | `reference_index` | 值必须是常量池的有效索引 |

#### 2.2.13. CONSTANT_MethodType_info

| 存储结构 | 名称    | 描述                    |
| -------- | ------- | ----------------------- |
| `u1`     | `tag`   | 值为`16`                 |
| `u2`     | `descriptor_index` | 值必须是常量池的有效索引，常量池在该索引处的项必须是CONSTANT_Utf8_info结构，表示方法的描述符 |

#### 2.2.14. CONSTANT_InvokeDynamic_info

| 存储结构 | 名称    | 描述                    |
| -------- | ------- | ----------------------- |
| `u1`     | `tag`   | 值为`18`                 |
| `u2`     | `bootstrap_method_attr_index` | 值必须是对当前Class文件中引导方法表的bootstrap_methods[]数组的有效索引 |
| `u2`     | `descriptor_index` | 值必须是常量池的有效索引，常量池在该索引处的项必须是CONSTANT_NameAndType_info结构，表示方法名和方法描述符 |


常量池，可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一。

## 3. 第三层：炸死TA搜搜again

### 3.1. Access Flags

| 数据结构         | 名称                  | 数量                      |
| ---------------- | --------------------- | ------------------------- |
| `cp_info`        | `constant_pool`       | `constant_pool_count - 1` |
| `u2`             | `access_flags`        | `1`                       |
| `u2`             | `this_class`          | `1`                       |

在常量池结束之后，紧接着的两个字节代表访问标志(access_flags)，这个标志用于识别一些类或接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。

具体的标志位及标志的含义如下表。

| 标志值   | 标志名称         | 含义                                                         |
| -------- | ---------------- | ------------------------------------------------------------ |
| `0x0001` | `ACC_PUBLIC`     | 是否为`public`类型                                           |
| `0x0010` | `ACC_FINAL`      | 是否被声明为`final`，只有类可设置                            |
| `0x0020` | `ACC_SUPER`      | 是否允许使用`invokespecial`字节码指定的新语意，`invokespecial`指令的语音是在`JDK 1.0.2`发生过改变，为了区别这条指令使用哪种语音，`JDK 1.0.2`之后编译出来的类的这个标志都必须为真。 |
| `0x0200` | `ACC_INTERFACE`  | 标识这是一个接口                                             |
| `0x0400` | `ACC_ABSTRACT`   | 是否为`abstract`类型，对于接口或者抽象类来说，此标志值为真，其他类值为假。 |
| `0x1000` | `ACC_SYNTHETIC`  | 标识这个类并非由用户代码产生的                               |
| `0x2000` | `ACC_ANNOTATION` | 标识这是一个注解                                             |
| `0x4000` | `ACC_ENUM`       | 标识这是一个枚举                                             |
`access_flags`中一共有16个标志位可以使用，当前只定义了其中8个，没有使用到的标志位要求一律为`0`。

> 此处应该有一张图：一共16个位置，表示16个位置，显示出各个位置上的意思。

<hr/>

类索引(`this_class`)和父类型索引(`parent_class`)都是一个`u2`类型的数据，而接口索引集合(`interfaces`)是一组`u2`类型的数据的集合，Class文件中由这三项数据来确定这个类的继承关系。

- 类索引(`this_class`)用于确定这个类的全限定名(Fully Qualified Class Name)。
- 父类索引(`parent_class`)用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了`java.lang.Object`之外，所有的Java类都有父类，因此除了`java.lang.Object`外，所有Java类的父类索引都不为`0`。
- 接口索引集合(`interfaces`)就用来描述这个类实现了哪些接口，这些被实现的接口将按`implements`语句（如果这个类本身是一个接口，则应当是`extends`语句）后的接口顺序从左到右排列在接口索引集合中。

#### 3.1.1. ACC_SUPER

```java
class HelloWorld {

}
```

- Hex Code: `0x0020`
- Flag Name: `[ACC_SUPER]`

#### 3.1.2. ACC_PUBLIC

```java
public class HelloWorld {

}
```

- Hex Code: `0x0021`
- Flag Name: `[ACC_SUPER,ACC_PUBLIC]`

#### 3.1.3. ACC_ABSTRACT

```java
abstract class HelloWorld {

}
```

- Hex Code: `0x0420`
- Flag Name: `[ACC_ABSTRACT,ACC_SUPER]`

#### 3.1.4. ACC_INTERFACE

```java
interface HelloWorld {

}
```

- Hex Code: `0x0600`
- Flag Name: `[ACC_ABSTRACT,ACC_INTERFACE]`

#### 3.1.5. ACC_FINAL

```java
final class HelloWorld {

}
```

- Hex Code: `0x0030`
- Flag Name: `[ACC_SUPER,ACC_FINAL]`

#### 3.1.6. ACC_ENUM

```java
enum HelloWorld {
    FIRST,
    SECOND
}
```

- Hex Code: `0x4030`
- Flag Name: `[ACC_ENUM,ACC_SUPER,ACC_FINAL]`

### 3.2. This Class

| 数据结构         | 名称                  | 数量                      |
| ---------------- | --------------------- | ------------------------- |
| `u2`             | `access_flags`        | `1`                       |
| `u2`             | `this_class`          | `1`                       |
| `u2`             | `super_class`         | `1`                       |

### 3.3. Super Class

| 数据结构         | 名称                  | 数量                      |
| ---------------- | --------------------- | ------------------------- |
| `u2`             | `this_class`          | `1`                       |
| `u2`             | `super_class`         | `1`                       |
| `u2`             | `interfaces_count`    | `1`                       |

类：`java.lang.Object`

```txt
|017| CLASS: {index=17, tagHex=07(7), classIndex=66, value='java.lang.Object', pattern='tag(2)-nameIndex(4)', hexCode='070042'}

This Class: {classIndex=17, hexCode='0011', value='java.lang.Object'}
Super Class: {classIndex=0, hexCode='0000', value='null'}
```

对于`java.lang.Object`类的`Super Class`，要注意两点：

- (1)`java.lang.Object`类的父类的索引值为`0`；其他类的父类的索引值都不为`0`。
- (2)回顾一下：常量池中对于索引为`0`的常量的解释。

### 3.4. Interfaces

| 数据结构         | 名称                  | 数量                      |
| ---------------- | --------------------- | ------------------------- |
| `u2`             | `super_class`         | `1`                       |
| `u2`             | `interfaces_count`    | `1`                       |
| `u2`             | `interfaces`          | `interfaces_count`        |
| `u2`             | `fields_count`        | `1`                       |

对于接口索引集合，入口的第一项是`u2`类型的数据为接口计数器(`interfaces_count`)，表示索引表的容量。如果该类没有实现任何接口，则该计数器值为`0`,后面接口索引表(`interfaces`)不再占用任何字节。

思路：

- (1)实现0个接口的类
- (2)实现1个（或2个）接口的类

## 4. 第四层：曾经沧海难为水

讲解思路：fields和methods一起对照着讲。

### 4.1. Fields

| 数据结构         | 名称                  | 数量                      |
| ---------------- | --------------------- | ------------------------- |
| `u2`             | `interfaces`          | `interfaces_count`        |
| `u2`             | `fields_count`        | `1`                       |
| `field_info`     | `fields`              | `fields_count`            |
| `u2`             | `methods_count`       | `1`                       |

#### 4.1.1. fields_count

`fields_count`是一个`u2`类型的容量计数器。

#### 4.1.2. fields_info

字段表(`field_info`)用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括方法内部声明的局部变量。

我们可以想一想在Java中描述一个字段可以包含什么信息？可以包括的字段有：字段的作用域（public、private、protected修饰符）、是实例变量还是类变量（static修饰符）、可见性（final）、并发可见性（volatile修饰符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段类型（基本类型、对象、数组）、字段名称。

在上述信息中，

- 各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。
- 而字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。

字段表(`field_info`)结构

| 数据结构         | 名称               | 数量               |
| ---------------- | ------------------ | ------------------ |
| `u2`             | `access_flags`     | `1`                |
| `u2`             | `name_index`       | `1`                |
| `u2`             | `descriptor_index` | `1`                |
| `u2`             | `attributes_count` | `1`                |
| `attribute_info` | `attributes`       | `attributes_count` |

字段修饰符放在`access_flags`项目中，它与类中的`access_flags`项目是非常类似的，都是一个`u2`的数据类型。



字段访问标志如下：

| 标志值   | 标志名称        | 含义                     |
| -------- | --------------- | ------------------------ |
| `0x0001` | `ACC_PUBLIC`    | 字段是否为`public`       |
| `0x0002` | `ACC_PRIVATE`   | 字段是否为`private`      |
| `0x0004` | `ACC_PROTECTED` | 字段是否为`protected`    |
| `0x0008` | `ACC_STATIC`    | 字段是否为`static`       |
| `0x0010` | `ACC_FINAL`     | 字段是否为`final`        |
| `0x0040` | `ACC_VOLATILE`  | 字段是否为`volatile`     |
| `0x0080` | `ACC_TRANSIENT` | 字段是否为`transient`    |
| `0x0100` | `ACC_SYNTHETIC` | 字段是否由编译器自动产生 |
| `0x4000` | `ACC_ENUM`      | 字段是否为`enum`         |

很明显，在实际情况中，`ACC_PUBLIC`、`ACC_PRIVATE`、`ACC_PROTECTED`三个标志最多只能选择其中一个，`ACC_FINAL`、`ACC_VOLATILE`不能同时选择。接口之中的字段必须有`ACC_PUBLIC`、`ACC_STATIC`、`ACC_FINAL`标志，这些都是由Java本身的语言规则所决定的。

> TODO:access_flags的访问标志举例`Example_08_Fields_0B_AccessFlags`

##### 4.1.2.1. `ACC_PUBLIC`～`ACC_TRANSIENT`

```java
public class HelloWorld {
    public int publicField;
    private int privateField;
    protected int protectedField;

    static int staticField;
    final int finalField = 1;

    volatile int volatileField;
    transient int transientField;
}
```

关于`public`、`private`和`protected`这三个关键字，没有什么特别需要说明的地方。重点说一下这4个修饰符：

- static
- final
- volatile
- transient

第一，关于`static`关键字。下面是从“类变量”和“实例变量”的角度来说的。来自《The Java Language Specification Java SE 8 Edition》的第8.3.1.1节p218。

> If a field is declared `static`, there exists exactly one incarnation of the field, no matter how many instances (possibly zero) of the class may eventually be created. A `static` field, sometimes called a **class variable**, is incarnated when the class is initialized.（大概意思：被`static`修饰的field，被称为class variable）

> A field that is **not** declared `static` (sometimes called a `non-static` field) is called an **instance variable**. Whenever a new instance of a class is created, a new variable associated with that instance is created for every instance variable declared in that class or any of its superclasses.（大概意思：没有被`static`修饰的field，被称为instance variable）

第二，关于`final`关键字。重点把握两方面：（1）无论是类变量，还是实例变量，`final`修饰的字段都需要初始化（本句重点），只是初始化的时机不同（次要重点）；（2）`final`修饰的字段一旦赋值后，就不能进行更改。下面是从“类变量”和“实例变量”的对于`final`修饰的字段进行初始化的时机不同的角度来说的。来自《The Java Language Specification Java SE 8 Edition》的第8.3.1.1节p218。

> A field can be declared `final`. Both **class** and **instance variables** (`static` and `non-static` fields) may be declared `final`. （大概意思：无论是类变量，还是实例变量，都可以使用`final`进行修饰。）

> A blank `final` **class variable** must be definitely assigned by **a static initializer of the class** in which it is declared, or a compile-time error occurs. （大概意思，对于类变量，对`final`字段进行初始化的时机在于`static initializer`内）

> A blank `final` **instance variable** must be definitely assigned at the end of **every constructor of the class** in which it is declared, or a compile-time error occurs. （大概意思，对于类变量，对`final`字段进行初始化的时机在于`class constructor`内）

第三，关于`transient`关键字。下面这段话是从**可持久化（序列化）**的角度来说的。来自《The Java Language Specification Java SE 8 Edition》的第8.3.1.3节p221。

> Variables may be marked `transient` to indicate that they are not part of the persistent state of an object. （大概意思：默认情况下，类里的字段在进行序列化的时候，都会输出；而被`transient`修饰的字段，则不需要输出。）

```java
import java.io.File;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.nio.file.Files;
import java.nio.file.Path;

public class HelloWorld  implements Serializable {

    private static final long serialVersionUID = 1L;

    private String name;
    private int age;

    public HelloWorld(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "HelloWorld {" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    public static void main(String[] args) {

        String dir = HelloWorld.class.getResource(".").getPath();
        String filename = dir + "object.ser";
        final Path storage = new File(filename).toPath();
        System.out.println(filename);


        HelloWorld instance = new HelloWorld("Tom", 10);
        System.out.println(instance);
        try( final ObjectOutputStream out = new ObjectOutputStream( Files.newOutputStream( storage ) ) ) {
            out.writeObject(instance);
        } catch (IOException e) {
            e.printStackTrace();
        }

        try( final ObjectInputStream in = new ObjectInputStream(Files.newInputStream(storage))) {
            final HelloWorld another = ( HelloWorld )in.readObject();
            System.out.println(another);
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }

    }
}
```

第四，关于`volatile`关键字。下面三段话是从“并发”的角度来说的。来自《The Java Language Specification Java SE 8 Edition》的第8.3.1.4节p222。

> The Java programming language allows threads to access shared variables . As a rule, to ensure that shared variables are consistently and reliably updated, a thread should ensure that it has exclusive use of such variables by obtaining a lock that, conventionally, enforces mutual exclusion for those shared variables. （大概意思：Java语言实现并发的第一种方式是使用`lock`。）

> The Java programming language provides a second mechanism, `volatile` fields, that is more convenient than locking for some purposes. （大概意思：Java语言实现并发第二种方式是使用`volatile`关键字。）

> A field may be declared `volatile`, in which case the Java Memory Model ensures that all threads see a consistent value for the variable. （大概意思：`volatile`关键字的具体作用，就是让所有的线程看到的变量值是一致的。）

##### 4.1.2.2. Interface Fields: `ACC_PUBLIC`, `ACC_STATIC` 和 `ACC_FINAL`

Every field declaration in the body of an interface is implicitly `public`, `static`, and `final`. 这是从Java语言的角度来说，这句英文来自《The Java Language Specification Java SE 8 Edition》的第9.3节p285。

> 翻译：在接口(interface)中声明的每一个字段(field)默认是`public`、`static`和`final`修饰。

Fields of interfaces must have their `ACC_PUBLIC`, `ACC_STATIC`, and `ACC_FINAL` flags set. 这是从`.class`文件字节码(byte code)的角度来说的，这句英文来自《The Java Virtual Machine Specification Java SE 8 Edition》的第4.5节p91。

```java
public interface HelloWorld {
    int width = 10;
}
```

- Access Flags Hex Code: `0x0019`
- Access Flags: `[ACC_FINAL,ACC_STATIC,ACC_PUBLIC]`

##### 4.1.2.3. ACC_SYNTHETIC

下面的代码，在byte code中会生成隐藏的`$VALUES`字段，由于是compiler生成的，因此带有`ACC_SYNTHETIC`。

```java
enum HelloWorld {
    FIRST,
    SECOND
}
```

跟随`access_flags`标志的是两项索引值：`name_index`和`descriptor_index`。

- `name_index`，表示“简单名称”
- `descriptor_index`，表示“（字段或方法的）描述符”

现在来解释一下“简单名称”、“描述符”和“全限定名”三个概念：

假设有一个类`cn.lsieun.HelloWorld`

- 简单名称。指没有类型和参数修饰的方法或字段名称。
- 描述符。用来描述字段的数据类型、方法的参数列表（包括数量、类型及顺序）和返回值。
- 全限定名。`cn/lsieun/HelloWorld`是这个类的全限定名，仅仅是把类全名中的`.`替换成了`/`而已。为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个`;`表示全限定名结束。

> 从字段和方法两个角度来举例说明：

字段、方法
简单名称
描述符
全限定名

根据描述符规则，基本数据类型（`byte`、`char`、`double`、`float`、`int`、`long`、`short`、`boolean`）以及代表返回值的`void`类型都用一个大写字符来表示，而对象类型则用字符`L`加对象的全限定名来表示。

描述符标识字符含义

| 标识字符 | 含义                            |
| -------- | ------------------------------- |
| `B`      | 基本类型`byte`                  |
| `C`      | 基本类型`char`                  |
| `D`      | 基本类型`double`                |
| `F`      | 基本类型`float`                 |
| `I`      | 基本类型`int`                   |
| `J`      | 基本类型`long`                  |
| `S`      | 基本类型`short`                 |
| `Z`      | 基本类型`boolean`               |
| `V`      | 特殊类型`void`                  |
| `L`      | 对象类型，如`Ljava/lang/Object`  |

对于数组类型，每一个维度将使用一个前置的`[`字符来描述。例如，定义一个为`java.lang.String[][]`类型的二维数组，将被记录为`[[Ljava/lang/String;`；一个整型数组`int[]`被记录为`[I`。

总结分为4种类型：

- 基本类型
- 特殊类型
- 对象类型
- 数组类型

用描述符来描述方法时，按照“先参数列表，后返回值”的顺序描述。参数列表(写英文名称)按照参数的严格顺序放在一组小括号`()`之内。

举例思路：

- 有0个参数的方法（无参数方法）
- 有1个参数的方法
- 有2个参数的方法
- 有多个参数的方法
- 有变量参数的方法

有0个参数的方法（无参数方法）

- 方法`void inc()`的描述符为`()V`；
- `java.lang.String.toString()`的描述符为`()Ljava/lang/String`；

有多个参数的方法

- 方法`int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex)`的描述符为`([CII[CIII)I`

### 4.2. Methods

| 数据结构         | 名称                  | 数量                      |
| ---------------- | --------------------- | ------------------------- |
| `field_info`     | `fields`              | `fields_count`            |
| `u2`             | `methods_count`       | `1`                       |
| `method_info`    | `methods`             | `methods_count`           |
| `u2`             | `attributes_count`    | `1`                       |

方法表结构

| 数据结构         | 名称               | 数量               |
| ---------------- | ------------------ | ------------------ |
| `u2`             | `access_flags`     | `1`                |
| `u2`             | `name_index`       | `1`                |
| `u2`             | `descriptor_index` | `1`                |
| `u2`             | `attributes_count` | `1`                |
| `attribute_info` | `attributes`       | `attributes_count` |

因为`volatile`关键字和`transient`关键字不能修饰方法，所以方法的访问标志中没有了`ACC_VOLATILE`标志和`ACC_TRANSIENT`标志。与之相对的`synchronized`、`native`、`strictfp`和`abstract`关键字可以修饰方法，所以方法表的访问标志中增加了`ACC_SYNCHRONIZED`、`ACC_NATIVE`、`ACC_STRICTFP`和`ACC_ABSTRACT`标志。

| 标志值   | 标志名称           | 含义                           |
| -------- | ------------------ | ------------------------------ |
| `0x0001` | `ACC_PUBLIC`       | 方法是否为`public`             |
| `0x0002` | `ACC_PRIVATE`      | 方法是否为`private`            |
| `0x0004` | `ACC_PROTECTED`    | 方法是否为`protected`          |
| `0x0008` | `ACC_STATIC`       | 方法是否为`static`             |
| `0x0010` | `ACC_FINAL`        | 方法是否为`final`              |
| `0x0020` | `ACC_SYNCHRONIZED` | 方法是否为`synchronized`       |
| `0x0040` | `ACC_BRIDGE`       | 方法是否由编译器产生的桥接方法 |
| `0x0080` | `ACC_VARAGS`       | 方法是否接受不定参数           |
| `0x0100` | `ACC_NATIVE`       | 方法是否为`native`             |
| `0x0400` | `ACC_ABSTRACT`     | 方法是否为`abstract`           |
| `0x0800` | `ACC_STRICT`     | 方法是否为`strictfp`           |
| `0x1000` | `ACC_SYNTHETIC`    | 方法是否由编译器自动产生的     |

```java
public abstract class HelloWorld  {
    void testDefault() {
        //
    }

    public void testPublic() {
        //
    }

    private void testPrivate() {
        //
    }

    protected void testProtected() {
        //
    }

    static void testStatic() {
        //
    }

    final void testFinal() {
        //
    }

    synchronized void testSynchronized() {
        //
    }

    void testVarArgs(String name, int age, String ... info) {
        //
    }

    abstract void testAbstract();

    strictfp void testStrict() {
        //
    }
}
```

ACC_SYNTHETIC

```java
public class OuterClass {

    private class InnerClass {
        private int value;
        private int value2;
    }

    private void test() {
        InnerClass innerClass = new InnerClass();
        innerClass.value = 100;
        int i = innerClass.value;
        i = innerClass.value2;
    }
}
```


行文至此，也许有的读者会产生疑问，方法的定义可以通过访问标志(access_flags)、名称索引(name_index)、描述符索引(descriptor_index)表达清楚，但方法里面的代码去哪里了？方法的Java代码，经过编译器编译成字节码指令后，存放方法属性表集合中一个名称`Code`的属性里面，属性表作为Class文件中最具扩展性的一种数据项目，将在后续讲解。

- 访问标志(access_flags)
- 名称索引(name_index)
- 描述符索引(descriptor_index)

> 这里最好有一张图来显示各个部分的内容，指明哪里是“访问标志、名称索引、描述符索引”

需要解决的问题：

- 字段如何带有Attribute属性，我就是想举个例子
- 方法默认有一个方法，就是构造函数（无参数的构造函数）
- 方法的Code内容的解析
- IDEA的bytecode有些解析不出来是怎么回事儿呢？

与字段表集合相对应的，如果父类方法在子类中没有被重写(Override)，方法表集合中就不会出现来自父类的方法信息。但同样的，有可能会出现由编译器自动添加的方法，最典型的便是类构造器`<clinit>`方法和实例构造器`<init>`方法。

讲解思路：下面的也是方法的几种形式，联想天下有4种猴子

> 天下只有四种神猴,能够超脱三界之外超脱三界之外,不在五行之中。
> 第一是灵明石猴，通变化，识天时，知地利，移星换斗。第二是赤尻马猴，晓阴阳，会人事，善出入，避死延生。第三是通臂猿猴，拿日月，缩千山，辨休咎，乾坤摩弄。第四是六耳猕猴，善聆音，能察理，知前后，万物皆明。此四猴者，不入十类之种，不达两间之名。悟空大概是灵明石猴。

- （1）常规的方法
- （2）Override父类的方法
- （3）重载(Overload)方法，在同一个类中
- （4）类构造器`<clinit>`方法和实例构造器`<init>`方法

> 我需要测试的问题：Override父类的方法、重载(Overload)方法、类构造器`<clinit>`方法和实例构造器`<init>`方法

在Java语言中，要重载(Overload)一个方法，除了要与原方法具有相同的“简单名称”之外，还要求必须拥有一个与原方法不同的“特征签名”。特征签名，就是一个方法中各个参数在常量池的字段符号引用的集合，也就是因为返回值不会包含在特征签名中，因此Java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。但是，在Class文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法也可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的。

对于“特征签名”这一个概念，Java语言和字节码对于这一个概念所支持程度是不一样的：

- Java代码的方法特征签名，只包括了方法名称、参数顺序及参数类型
- 字节码的特征签名，除了包含以上三者外，还包括方法返回值以及受查异常表。

### 4.3. Attributes

属性表(attribute_info)

| 数据结构         | 名称                  | 数量                      |
| ---------------- | --------------------- | ------------------------- |
| `method_info`    | `methods`             | `methods_count`           |
| `u2`             | `attributes_count`    | `1`                       |
| `attribute_info` | `attributes`          | `attributes_count`        |

在Class文件、字段表、方法表，都可以携带自己的属性表集合，用于描述某些场景专有的信息。

在Class文件中，属性表集合有一些“特殊性”。在Class文件中，其他的数据项（`magic_number`、`minor_version`、`major_version`、……`method_info`）对于顺序、长度和内容都有严格要求；而属性表集合的限制就稍微宽松了一些，不再要求各个属性表具有严格顺序，并且只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息。既然是自己定义的属性信息，那就有一个问题：如果Java虚拟机不认识，那该怎么办呢？Java虚拟机运行时会忽略掉它不认识的属性。

> 下面开始谈属性的「标准化」

为了正确解析Class文件，《Java虚拟机规范（第2版）》中预定义了9项虚拟机实现应当能识别的属性，而在《Java虚拟机规范（Java SE 7）》版中，预定义属性已经增加到21项。

在《The Java Virtual Machine Specification Java SE 8 Edition》的第4.7节p95定义了23种属性。

> 23 attributes are predefined by this specification.

> 教与学  
> 此处的学习目标：  
> （1）从课程（教）的角度来说，列一个表，是为了“完备性”  
> （2）从“学”的角度，初期不需要细看，后期可用作查阅。

虚拟机规范预定义的属性

| 属性名称                               | 使用位置           |
| -------------------------------------- | ------------------ |
| `Code`                                 | 方法表             |
| `ConstantValue`                        | 字段表             |
| `Deprecated`                           | 类、方法表、字段表 |
| `Exceptions`                           | 方法表             |
| `EnclosingMethod`                      | 类文件             |
| `InnerClasses`                         | 类文件             |
| `LineNumberTable`                      | Code属性           |
| `LocalVariableTable`                   | Code属性           |
| `StackMapTable`                        | Code属性           |
| `Signature`                            | 类、方法表、字段表 |
| `SourceFile`                           | 类文件             |
| `SourceDebugExtension`                 | 类文件             |
| `Synthetic`                            | 类、方法表、字段表 |
| `LocalVariableTypeTable`               | 类                 |
| `RuntimeVisibleAnnotations`            | 类、方法表、字段表 |
| `RuntimeInvisibleAnnotations`          | 类、方法表、字段表 |
| `RuntimeVisibleParameterAnnotations`   | 方法表             |
| `RuntimeInvisibleParameterAnnotations` | 方法表             |
| `AnnotationDefault`                    | 方法表             |
| `BootstrapMethods`                     | 类文件             |
|                                        |                    |

这个表，可以拆分成4个表，第1个表是公共的；第2、3、4个表分别对应类、字段和方法。

虚拟机规范预定义属性的含义



- `Code`： Java代码编译成的字节码指令
- `ConstantValue`： `final`关键字定义的常量值
- `Deprecated`： 被声明为`deprecated`的方法和字段
- `Exceptions`： 方法抛出的异常
- `EnclosingMethod`： 仅当一个类为局部类或者匿名类时，才能拥有这个属性，这个属性用于标识这个类所在的外围方法
- `InnerClasses`： 内部类列表
- `LineNumberTable`： Java源码的行号与字节码指令的对应关系
- `LocalVariableTable`： 方法的局部变量描述
- `StackMapTable`： `JDK 1.6`中新增的属性，供新的类型检查验证器(Type Checker)检查和处理目标方法的局部变量和操作数栈所需要的类型是否匹配
- `Signature`： `JDK 1.5`中新增的属性，这个属性用于支持泛型情况下的方法签名，在Java语言中，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量(Type Variable)或参数化类型(Parameterized Types)，则`Signature`属性会为它记录泛型签名信息。由于Java的泛型采用擦除法实现，在为了避免类型信息被擦除后导致签名混乱，需要这个属性记录泛型中的相关信息
- `SourceFile`： 记录源文件名称
- `SourceDebugExtension`： `JDK 1.6`中新增的属性，`SourceDebugExtension`属性用于存储额外的调试信息。譬如在进行`JSP`文件调试时，无法通过Java堆栈来定位到`JSP`文件的行号，`JSR-45`规范为这些非Java语言编写、却需要编译成字节码并运行在Java虚拟机中程序提供了一个进行调试的标准机制，使用`SourceDebugExtension`属性就可以用于存储这个标准所新加入的调试信息
- `Synthetic`： 标识方法或字段为编译器自动生成的
- `LocalVariableTypeTable`： `JDK 1.5`中新增的属性，它使用特征签名(Signature)代替描述符(Descriptor)，是为了引入泛型语法之后能描述泛型参数化类型而添加
- `RuntimeVisibleAnnotations`： `JDK 1.5`中新增的属性，为动态注解提供支持。`RuntimeVisibleAnnotation`属性用于指明哪些注解是运行时（实际运行时就是进行反射调用）可见的
- `RuntimeInvisibleAnnotations`： `JDK 1.5`中新增的属性，与`RuntimeVisibleAnnotations`属性作用刚好相反，用于指明哪些注解是运行时不可见的。
- `RuntimeVisibleParameterAnnotations`： `JDK 1.5`中新增的属性，作用与`RuntimeVisibleAnnotations`属性类似，只不过作用对象为方法参数
- `RuntimeInvisibleParameterAnnotations`： `JDK 1.5`中新增的属性，作用与`RuntimeInvisibleAnnotation`属性类似，只不过作用对象为方法参数
- `AnnotationDefault`： `JDK 1.5`中新增的属性，用于记录注解类元素的默认值
- `BootstrapMethods`： `JDK 1.7`中新增的属性，用于保存`invokedynamic`指令引用的引导方法限定符

一个符合规则的属性表应满足如下所定义的结构。

属性表结构

| 数据结构 | 名称                   | 数量               |
| -------- | ---------------------- | ------------------ |
| `u2`     | `attribute_name_index` | `1`                |
| `u4`     | `attribute_length`     | `1`                |
| `u1`     | `info`                 | `attribute_length` |


对于每个属性，它的名称需要从常量池中引用一个`CONSTANT_Utf8_info`类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个`u4`的长度属性来说明属性值所占用的位数即可。

> 此处，应该查看例子进行说明，不只是讲

#### 4.3.1. Code属性

> 说其重要性

`Code`属性是`Class`文件中最重要的一个属性。如果把一个Java程序中的信息分为代码（`Code`，方法体里面的Java代码）和元数据（`Metadata`，包括类、字段、方法定义及其他信息）两部分，那么在整个Class文件中，`Code`属性用于描述代码，所有的其他数据项目都用于描述元数据。了解`Code`属性是学习字节码执行引擎内容的必要基础。

讲解思路：先讲解一般的，就是有方法体的方法；再讲特殊的，比如说接口、抽象类。

Java程序方法体中的代码经过`javac`编译器处理后，最终变为字节码指令存储在`Code`属性内。`Code`属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性。譬如接口或抽象类中的方法就不存在`Code`属性。

> 想法：看看接口、抽象类中定义的方法，是什么样的，有没有Code属性。

如果方法表有`Code`属性存在，那么它的结构如下所示。

`Code`属性表的结构

| 数据结构         | 名称                     | 数量                     |
| ---------------- | ------------------------ | ------------------------ |
| `u2`             | `attribute_name_index`   | `1`                      |
| `u4`             | `attribute_length`       | `1`                      |
| `u2`             | `max_stack`              | `1`                      |
| `u2`             | `max_locals`             | `1`                      |
| `u4`             | `code_length`            | `1`                      |
| `u1`             | `code`                   | `code_length`            |
| `u2`             | `exception_table_length` | `1`                      |
| `exception_info` | `exception_table`        | `exception_table_length` |
| `u2`             | `attributes_count`       | `1`                      |
| `attribute_info` | `attributes`             | `attributes_count`       |

- `attribute_name_index`是一项指向`CONSTANT_Utf8_info`型常量的索引，常量值固定为`Code`，它代表了该属性的属性名称
- `attribute_length`指示了属性值的长度。由于属性名称索引(`attribute_name_index`)和属性长度(`attribute_length`)一共为6字节，所以属性值的长度固定为整个属性表长度减去6个字节。
- `max_stack`代表了操作数栈(Operand Stacks)深度的最大值。在方法执行的任意时刻，操作数栈都不会超过这个深度。虚拟机运行的时候，需要根据这个值来分配栈桢(Stack Frame)中的操作栈深度。
- `max_locals`代表了“局部变量表”所需的存储空间。在这里，`max_locals`的单位是`Slot`。

> `Slot`是虚拟机为局部变量分配内存所使用的最小单位。对于`byte`、`char`、`float`、`int`、`short`、`boolean`和`returnAddress`等长度不超过32位的数据类型的数据类型，每个局部变量占用1个`Slot`，而`double`和`long`这两种64位的数据类型则需要2个`Slot`来存储。  
> 方法参数（包括实例方法中的隐藏参数`this`）、显式异常处理器的参数（Exception Handler Parameter，就是`try-catch`语句中`catch`块所定义的异常）、方法体中定义的局部变量都需要使用“局部变量表”来存放。 「“局部变量表”存放的内容，这是定性的描述」  
> 另外，并不是在方法中用到了多少局部变量，就把这些局部变量所占`Slot`之和作为`max_locals`的值，原因是局部变量表中的`Slot`可以重用。当代码执行超出一个局部变量的作用域时，这个局部变量所占的`Slot`可以被其他局部变量所使用。`javac`编译器会根据变量的作用域来分配`Slot`给各个变量使用，然后计算出`max_locals`的大小。「这是讲大小是怎么算的，是“定量”角度的描述」

- `code_length`和`code`，用来存储Java源程序编译后生成的字节码指令。
- `code_length`代表字节码长度。
- `code`是用于存储字节码指令的一系列字节流。

> 既然叫“字节码指令”，那么每个指令就是一个`u1`类型的单字节，当虚拟机读取到`code`中一个字节码时，就可以对应找出这个字节码代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数，以及参数应当如何理解。  
> 我们知道一个`u1`数据类型的取值范围为`0x00~0xFF`，对应十进制的`0~255`，也就是一共可以表达256条指令。目前，Java虚拟机规范已经定义了约200条编码值对应的指令含义，编码与指令之间的对应关系称为“虚拟机字节码指令表”。  
>   
> 有一件事情需要注意，虽然`code_length`是一个`u4`类型的长度值，理论上最大值可以达到2<sup>32</sup>-1，但是虚拟机规范中明确限制了一个方法不允许超过65535(2<sup>16</sup> = 65536)条字节码指令，即它实际只使用了`u2`的长度。如果超过这个限制（65535条字节码指令），`javac`编译器也会拒绝编译。一般来讲，编写Java代码时只要不是刻意去编写一个超长的方法来为难编译器，是不太可能超过这个最大值的限制。但是，某些特殊情况，例如在编译一个很复杂的JSP文件时，某些JSP编译器会把JSP内容和页面输出的信息归并到一个方法之中，就可能因为方法生成字节码超长的原因而导致编译失败。

在字节码指令(`code`)之后的是这个方法的“显式异常处理表”（下文简称“异常表”）集合。“异常表”对于`Code`属性来说，并不是必须存在的。

属性表结构

| 数据类型 | 名称         | 数量 |
| -------- | ------------ | ---- |
| `u2`     | `start_pc`   | `1`  |
| `u2`     | `end_pc`     | `1`  |
| `u2`     | `handler_pc` | `1`  |
| `u2`     | `catch_type` | `1`  |

异常表，包含4个字段。这些字段的含义为：`start_pc`、`end_pc`、`handler_pc`和`catch_type`。这些字段的含义为：如果当字节码在`start_pc`行到第`end_pc`行（不含第`end_pc`行）出现了类型为`catch_type`或者其子类的异常（`catch_type`为指向一个`CONSTANT_Class_info`型常量的索引），则转到第`handler_pc`行继续处理。当`catch_type`的值为`0`时，代表任意异常情况都需要转向到`handler_pc`处理进行处理。

异常表实际上是Java代码的一部分，编译器使用异常表而不是简单的跳转指令来实现Java异常及`finally`处理机制。

想法：我应该用实际的代码来展示，它的书的187(PDF208)页的代码例子很不错的。

> 在`JDK 1.4.2`之前的`javac`编译器采用`jsr`和`ret`指令实现`finally`语句，但`JDK 1.4.2`之后改为编译器自动在每段可能的分支路径之后都将finally语句块的内容冗余生成一遍来实现finally语义。在`JDK 1.7`中，已经完全禁止Class文件中出现`jsr`和`ret`指令，如果遇到这两条指令，虚拟机会在类加载的字节码校验阶段抛出异常。

#### 4.3.2. Exceptions属性

这里的`Exceptions`属性是在方法表中与`Code`属性平级的一项属性，读者不要与前面刚刚讲解的“异常表”产生混淆。`Exceptions`属性的作用是列举出方法中可能抛出的受查异常(Checked Exceptions)，也就是方法描述时在`throws`关键字后面列举的异常。

`Exceptions`属性表结构

| 数据结构 | 名称                    | 数量                   |
| -------- | ----------------------- | ---------------------- |
| `u2`     | `attribute_name_index`  | `1`                    |
| `u4`     | `attribute_length`      | `1`                    |
| `u2`     | `number_of_exceptions`  | `1`                    |
| `u2`     | `exception_index_table` | `number_of_exceptions` |

`Exceptions`属性中的`number_of_exceptions`项表示方法可能抛出`number_of_exceptions`种受查异常，每一种受查异常使用一个`exception_index_table`项表示，`exception_index_table`是一个指向常量池中`CONSTANT_Class_info`型常量的索引，代表了该受查异常的类型。

#### 4.3.3. LineNumberTable属性

`LineNumberTable`属性用于描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。它并不是运行时必需的属性，但默认会生成到Class文件之中，可以在`javac`中分别使用`-g:none`或`-g:lines`选项来取消或生成这项信息。如果选择不生成`LineNumberTable`属性，对程序运行产生的最主要的影响就是抛出异常时，堆栈中将不会显出错的行号，并且调试程序的时候，也无法按照源码行来设置断点。

`LineNumberTable`属性结构

| 数据结构           | 名称                       | 数量                       |
| ------------------ | -------------------------- | -------------------------- |
| `u2`               | `attribute_name_index`     | `1`                        |
| `u4`               | `attribute_length`         | `1`                        |
| `u2`               | `line_number_table_length` | `1`                        |
| `line_number_info` | `line_number_table`        | `line_number_table_length` |

`line_number_table`是一个数量为`line_number_table_length`、类型为`line_number_info`的集合，`line_number_info`表包括了`start_pc`和`line_number`两个`u2`类型的数据项，前者是字节码行号，后者是Java源码行号。

#### 4.3.4. LocalVariableTable属性

`LocalVariableTable`属性用于描述栈桢中局部变量表中的变量与Java源码中定义的变量之间的关系，它也不是运行时必需的属性，但默认会生成到Class文件之中，可以在`javac`中分别使用`-g:none`或`-g:vars`选项来取消或要生成这项信息。如果没有生成这项属性，最大的影响就是当其他人引用这个方法时，所有的参数名称将会丢失，IDE将会使用诸如`arg0`、`arg1`之类的占位符代替原有的参数名，这对程序运行没有影响，但是对代码编写带来较大不便，而且在调试期间无法根据参数名称从上下文中获得参数值。

`LocalVariableTable`属性结构

| 数据结构              | 名称                          | 数量                          |
| --------------------- | ----------------------------- | ----------------------------- |
| `u2`                  | `attribute_name_index`        | `1`                           |
| `u4`                  | `attribute_length`            | `1`                           |
| `u2`                  | `local_variable_table_length` | `1`                           |
| `local_variable_info` | `local_variable_table`        | `local_variable_table_length` |

其中，`local_variable_info`项目代表了一个栈桢与源码中的局部变量的关联。

`local_variable_info`项目结构

| 数据结构 | 名称               | 数量 |
| -------- | ------------------ | ---- |
| `u2`     | `start_pc`         | `1`  |
| `u2`     | `length`           | `1`  |
| `u2`     | `name_index`       | `1`  |
| `u2`     | `descriptor_index` | `1`  |
| `u2`     | `index`            | `1`  |

`start_pc`和`length`属性分别代表了这个局部变量的生命周期开始的字节码偏移量及其作用覆盖的长度，两者结合起来就是这个局部变量在字节码之中的作用域范围。

`name_index`和`descriptor_index`都是指向常量池中`CONSTANT_Utf8_info`型常量的索引，分别代表了局部变量的名称以及这个局部变量的描述符。

`index`是这个局部变量在栈桢局部变量表中`Slot`的位置。当这个变量数据类型是64位类型时（`double`和`long`），它占用的`Slot`为`index`和`index+1`两个。

顺便提一下，在`JDK 1.5`引入泛型后，`LocalVariableTable`属性增加了一个“姐妹属性”：`LocalVariableTypeTable`，这个新增的属性结构与`LocalVariableTable`非常相似，仅仅是把记录的字段描述符的`descriptor_index`替换成了字段的特征签名(Signature)，对于非泛型类型来说，描述符和特征签名描述的信息是一致的，但是泛型引入后，由于描述泛型的参数化类型被擦除掉，描述符就不能准确描述泛型类型了，因此出现了`LocalVariableTypeTable`。


#### 4.3.5. SourceFile属性

`SourceFile`属性用于记录生成这个Class文件的源码文件名称。这个属性也是可选的，可以分别使用`javac`的`-g:none`或`-g:source`选项来关闭或要求生成这项信息。在Java中，对于大多数的类来说，类名和文件名是一致的，但是有一些特殊情况（如内部类）例外。如果不生成这项属性，当抛出异常时，堆栈中将不会显示出错代码所属的文件名。这个属性是一个定长属性。

`SourceFile`属性结构

| 数据结构 | 名称                   | 数量 |
| -------- | ---------------------- | ---- |
| `u2`     | `attribute_name_index` | `1`  |
| `u4`     | `attribte_length`      | `1`  |
| `u2`     | `sourcefile_index`     | `1`  |

#### 4.3.6. ConstantValue属性

`ConstantValue`属性的作用是通知虚拟机自动为静态变量赋值。只有被`static`关键字修饰的变量（类变量）才可以使用这项属性。类似`int x = 123`和`static int x = 123`这样的变量定义在Java程序中是非常常见的事情，但虚拟机对这两种变量赋值的方式和时刻都有所不同。对于非`static`类型的变量（也就是实例变量）的赋值是在实例构造器`<init>`方法中进行的；而对于类变量，则有两种方式可以选择：在类构造器`<clinit>`方法中或者使用`ConstantValue`属性。目前Sun Javac编译器的选择是：如果同时使用`final`和`static`来修饰一个变量（按照习惯，这里称“常量”更贴切），并且这个变量的数据类型是基本类型或者`java.lang.String`的话，就生成`ConstantValue`属性来进行初始化，如果这个变量没有被`final`修饰，或者并非基本类型及字符串，则将会选择在`<clinit>`方法中进行初始化。

虽然有`final`关键字才更符合`ConstantValue`的语义，但虚拟机规范中并没有强制要求字段必须设置了`ACC_FINAL`标志，只要求了有`ConstantValue`属性的字段必须设置`ACC_STATIC`标志而已，对`final`关键字的要求是`javac`编译器自己加入的限制。而对`ConstantValue`的属性值只能限于基本类型和`java.lang.String`，不过有人不认为这是什么限制，因为此属性的属性值只是一个常量池的索引号，由于Class文件格式的常量类型中只有与基本属性和字段串相对应的字面量，所以就算`ConstantValue`属性想支持别的类型也无能为力。

> 我是想做试验的：有final\final int\static int\static final int，看看这几种情况都是什么。换成String类型，又会是什么情况呢？

`ConstantValue`属性结构

| 数据结构 | 名称                   | 数量 |
| -------- | ---------------------- | ---- |
| `u2`     | `attribute_name_index` | `1`  |
| `u4`     | `attribute_length`     | `1`  |
| `u2`     | `constantvalue_index`  | `1`  |

从数据结构中可以看出，`ConstantValue`属性是一个定长属性，它的`attribute_length`数据项必须固定为`2`。`constantvalue_index`数据项代表了常量池中一个字面量常量的引用，根据字段类型的不同，字面量可以是`CONSTANT_Integer_info`、`CONSTANT_Long_info`、`Constant_Float_info`、`CONSTANT_Double_info`、`CONSTANT_String_info`常量中的一种。

#### 4.3.7. InnerClasses属性

`InnerClasses`属性用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成`InnerClasses`属性。

`InnerClasses`属性结构

| 数据结构             | 名称                   | 数量                |
| -------------------- | ---------------------- | ------------------- |
| `u2`                 | `attribute_name_index` | `1`                 |
| `u4`                 | `attribute_length`     | `1`                 |
| `u2`                 | `number_of_classes`    | `1`                 |
| `inner_classes_info` | `inner_classes`        | `number_of_classes` |

数据项`number_of_classes`代表需要记录多少个内部信息，每一个内部类的信息都由一个`inner_classes_info`表进行描述。

`inner_classes_info`表的结构。

| 数据结构 | 名称                       | 数量 |
| -------- | -------------------------- | ---- |
| `u2`     | `inner_class_info_index`   | `1`  |
| `u2`     | `outer_class_info_index`   | `1`  |
| `u2`     | `inner_name_index`         | `1`  |
| `u2`     | `inner_class_access_flags` | `1`  |

`inner_class_info_index`和`outer_class_info_index`都是指向常量池中`CONSTANT_Class_info`型常量的索引，分别代表了内部类和宿主类的符号引用。

`inner_name_index`是指向常量池中`CONSTANT_Utf8_info`型常量的索引，代表这个内部类的名称，如果是匿名类，那么这项值为`0`。

`inner_class_access_flags`是内部类的访问标志，类似于类的`access_flags`，它的取值范围见下表。

`inner_class_access_flags`标志

| 标志值   | 标志名称         | 含义                                 |
| -------- | ---------------- | ------------------------------------ |
| `0x0001` | `ACC_PUBLIC`     | 内部类是否为`public`                 |
| `0x0002` | `ACC_PRIVATE`    | 内部类是否为`private`                |
| `0x0004` | `ACC_PROTECTED`  | 内部类是否为`protected`              |
| `0x0008` | `ACC_STATIC`     | 内部类是否为`static`                 |
| `0x0010` | `ACC_FINAL`      | 内部类是否为`final`                  |
| `0x0020` | `ACC_INTERFACE`  | 内部类是否为`interface` 验证一下对错 |
| `0x0040` |                  |                                      |
| `0x0080` |                  |                                      |
| `0x0100` |                  |                                      |
| `0x0200` |                  |                                      |
| `0x0400` | `ACC_ABSTRACT`   | 内部类是否为`abstract`               |
| `0x0800` |                  |                                      |
| `0x1000` | `ACC_SYNTHETIC`  | 内部类是否并非由用户代码产生的       |
| `0x2000` | `ACC_ANNOTATION` | 内部类是否是一个注解                 |
| `0x4000` | `ACC_ENUM`       | 内部类是否是一个枚举                 |
| `0x8000` |                  |                                      |


#### 4.3.8. Deprecated及Synthetic属性

`Deprecated`和`Synthetic`两个属性都属于标志类型的布尔属性，只存在“有”和“没有”的区别，没有“属性值”的概念。

`Deprecated`属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通过在代码中使用`@deprecated`注释进行设置。

`Synthetic`属性代表此字段或方法并不是由Java源码直接产生的，而是由编译器自动添加的。在`JDK 1.5`之后，标识一个类、字段或者方法是编译器自动产生的，也可以设置它们访问标志中的`ACC_SYNTHETIC`标志位，其中最经典的例子就是`Bridge Method`。所有由非用户代码产生的类、方法及字段都应当至少设置`Synthetic`属性和`ACC_SYNTHETIC`标志位中的一项，唯一的例外是实例构造器`<init>`方法和类构造器`<clinit>`方法。

`Deprecated`和`Synthetic`属性的结构

| 数据结构 | 名称                   | 数量 |
| -------- | ---------------------- | ---- |
| `u2`     | `attribute_name_index` | `1`  |
| `u4`     | `attribute_length`     | `1`  |

其中，`attribute_length`数据项的值必须为`0x00000000`，因为没有任何属性值需要设置。

#### 4.3.9. StackMapTable属性

`StackMapTable`属性在`JDK 1.6`发布后增加到了Class文件规范中，它是一个复杂的变长属性，位于`Code`属性的属性表中。这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器(Type Checker)使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。

这个类型检查验证器最初来源于Sheng Liang（听名字似乎是虚拟机团队中的华裔成员）为Java ME CLDC实现的字节码验证器。新的验证器在同样保证Class文件合法的前提下，省略了在运行期通过数据流分析去确认字节码的行为逻辑合法性的步骤，而是在编译阶段将一系列的验证类型(Verification Types)直接记录在Class文件之中，通过检查这些验证类型代替了类型推导过程，从而大幅度提供了字节码验证的性能。这个验证器在`JDK 1.6`中首次提供，并在`JDK 1.7`中强制替换原本基本类型推断的字节码验证器。关于这个验证器的工作原理，《Java虚拟机规范（Java SE 7版）》花费了整整120页的篇幅来讲解描述，并且分析证明了新验证方法的严谨性，这里不再赘述。

`StackMapTable`属性包含零至多个栈映射帧(Stack Map Frames)，每个栈映射桢都显式或隐式地代表了一个字节码偏移量，用于表示该执行到该字节码时局部变量表和操作数栈的验证类型。类型检查验证器会通过检查目标方法的局部变量和操作数栈所需要的类型来确定一段字节码指令是否符合逻辑约束。

`StackMapTable`属性的结构

| 数据结构          | 名称                      | 数量                |
| ----------------- | ------------------------- | ------------------- |
| `u2`              | `attribute_name_index`    | `1`                 |
| `u4`              | `attribute_length`        | `1`                 |
| `u4`              | `number_of_entries`       | `1`                 |
| `stack_map_frame` | `stack_map_frame_entries` | `number_of_entries` |

《Java虚拟机规范（Java SE 7版）》明确规定：在版本号大于或等于`50.0`的Class文件中，如果方法`Code`属性中没有附带`StackMapTable`属性，那就意味着它带有一个隐式的`StackMap`属性。这个`StackMap`属性的作用等同于`number_of_entries`值为`0`的`StackMapTable`属性。一个方法的`Code`属性最多只能一个`StackMapTable`属性，否则将抛出`ClassFormatError`异常。

#### 4.3.10. Signature属性

`Signature`属性在`JDK 1.5`发布后增加到了Class文件规范之中，它是一个可选的定长属性，可以出现于类、属性表和方法表的属性表中。在`JDK 1.5`中大幅增强了Java语言的语法，在此之后，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量(Type Variables)或参数化类型(Parameterized Types)，则`Signature`属性会为它记录泛型签名信息。之所以要专门使用这样一个属性去记录泛型类型，是因为Java语言的泛型采用的是擦除法实现的伪泛型，在字节码（`Code`属性）中，泛型信息编译（类型变量、参数化类型）之后都通通被擦除掉。使用擦除法的好处是实现简单（主要修改`javac`编译器，虚拟机内部只做了很少的改动）、非常容易实现Backport，运行期也能够节省一些类型所占的内存空间。但坏处是运行期就无法像C#等有真泛型支持的语言那样，将泛型类型与用户定义的普通类型同等对待，例如运行期做反射时无法获得泛型信息。`Signature`属性就是为了弥补这个缺陷而增设的，现在Java的反射API能够获取泛型类型，最终的数据来源也就是这个属性。关于Java泛型、`Signature`属性和类型擦除，在介绍编译器优化的时候会通过一个具体的例子来讲解。



> 我要看一看到底是什么样，是怎么记录泛型信息的，与descriptor对比一下。
> Backport是什么意思呢？

`Signature`属性的结构

| 数据结构 | 名称                   | 数量 |
| -------- | ---------------------- | ---- |
| `u2`     | `attribute_name_index` | `1`  |
| `u4`     | `attribute_length`     | `1`  |
| `u2`     | `signature_index`      | `1`  |


其中，`signature_index`项的值必须是一个对常量池的有效索引。常量池在该索引处的项必须是`CONSTANT_Utf8_info`结构，表示类签名、方法类型签名或字段类型签名。如果当前的`Signature`属性是类文件的属性，则这个结构表示类签名；如果当前的`Signature`属性是方法表的属性，则这个结构表示方法类型签名；如果当前`Signature`属性是字段表的属性，则这个结构表示字段类型签名。

#### 4.3.11. BootstrapMethods属性

`BootstrapMethods`属性在`JDK 1.7`发布后增加到了Class文件规范之中，它是一个复杂的变长属性，位于类文件的属性表中。这个属性用于保存`invokedynamic`指令引用的引导方法限定符。《Java虚拟机规范（Java SE 7版）》规定，如果某个类文件结构常量池中曾经出现过`CONSTANT_InvokeDynamic_info`类型的常量，那么这个类文件的属性表中必须存在一个明确伯`BootstrapMethods`属性，另外，即使`CONSTANT_InvokeDynamic_info`类型常量在常量池中出现过多次，类文件的属性表中最多也只有一个`BootstrapMethods`属性。

`BootstrapMethods`属性与`JSR-292`中的`InvokeDynamic`指令和`java.lang.Invoke`包关系非常密切，要介绍这个属性的作用，必须先弄清楚`InvokeDynamic`指令的运作原理。

目前的`javac`暂时无法生成`InvokeDynamic`指令和`BootstrapMethods`属性，必须通过一些非常规的手段才能使用到它们，也许在不久的将来，等`JSR-292`更加成熟一些，这种情况就会改变。

`BootstrapMethods`属性的结构

| 数据结构           | 名称                    | 数量                    |
| ------------------ | ----------------------- | ----------------------- |
| `u2`               | `attribute_name_index`  | `1`                     |
| `u4`               | `attribute_length`      | `1`                     |
| `u2`               | `num_bootstrap_methods` | `1`                     |
| `bootstrap_method` | `bootstrap_methods`     | `num_bootstrap_methods` |

`bootstrap_method`属性的结构

| 数据结构 | 名称                      | 数量                      |
| -------- | ------------------------- | ------------------------- |
| `u2`     | `bootstrap_method_ref`    | `1`                       |
| `u2`     | `num_bootstrap_arguments` | `1`                       |
| `u2`     | `bootstrap_arguments`     | `num_bootstrap_arguments` |


`BootstrapMethods`属性中，`num_bootstrap_methods`项的值给出了`bootstrap_methods[]`数组中的引导方法限定符的数量。而`bootstrap_methods[]`数组的每个成员包含了一个指向常量池`CONSTANT_MethodHandle_info`结构的索引值，它代表了一个引导方法，还包含了这个引导方法静态参数的序列（可能为空）。

`bootstrap_methods[]`数组中的每个成员必须包含以下3项内容。

- `bootstrap_method_ref`：`bootstrap_method_ref`项的值必须是一个对常量池的有效索引。常量池在该索引处的值必须是一个`CONSTANT_MethodHandle_info`结构。
- `num_bootstrap_arguments`：`num_bootstrap_arguments`项的值给出了`bootstrap_arguments[]`数组成员的数量。
- `bootstrap_arguments`：`bootstrap_arguments[]`数组的每个成员必须是一个对常量池的有效索引。常量池在廖索引处必须是下列结构之一：`CONSTANT_Integer_info`、`CONSTANT_Long_info`、`CONSTANT_Float_info`、`CONSTANT_Double_info`、`CONSTANT_String_info`、`CONSTANT_Class_info`、`CONSTANT_MethodHandle_info`和`CONSTANT_MethodType_info`。


## 5. Glossary

### 5.1. access_flags对比：Class、Field、Method

> 做一个Class、Field、Method三者access_flags对比的表

三者对比

| 标志值   | Class标志名称           | Field标志名称               | Method标志名称                 |
| -------- | ----------------------- | --------------------------- | ------------------------------ |
| `0x0001` | `ACC_PUBLIC`            | `ACC_PUBLIC`                | `ACC_PUBLIC`                   |
| `0x0002` |                         | `ACC_PRIVATE`               | `ACC_PRIVATE`                  |
| `0x0004` |                         | `ACC_PROTECTED`             | `ACC_PROTECTED`                |
| `0x0008` |                         | `ACC_STATIC`                | `ACC_STATIC`                   |
| `0x0010` | `ACC_FINAL`             | `ACC_FINAL`                 | `ACC_FINAL`                    |
| `0x0020` | `ACC_SUPER`:astonished: |                             | `ACC_SYNCHRONIZED`:astonished: |
| `0x0040` |                         | `ACC_VOLATILE`:astonished:  | `ACC_BRIDGE`:astonished:       |
| `0x0080` |                         | `ACC_TRANSIENT`:astonished: | `ACC_VARARGS`:astonished:      |
| `0x0100` |                         |                             | `ACC_NATIVE`                   |
| `0x0200` | `ACC_INTERFACE`         |                             |                                |
| `0x0400` | `ACC_ABSTRACT`          |                             | `ACC_ABSTRACT`                 |
| `0x0800` |                         |                             | `ACC_STRICT`                 |
| `0x1000` | `ACC_SYNTHETIC`         | `ACC_SYNTHETIC`             | `ACC_SYNTHETIC`                |
| `0x2000` | `ACC_ANNOTATION`        |                             |                                |
| `0x4000` | `ACC_ENUM`              | `ACC_ENUM`                  |                                |
| `0x8000` |                         |                             |                                |



## 6. 不足之处

| 数据结构         | 名称                  | 数量                      |
| ---------------- | --------------------- | ------------------------- |
| `u4`             | `magic_number`        | `1`                       |
| `u2`             | `minor_version`       | `1`                       |
| `u2`             | `major_version`       | `1`                       |
| `u2`             | `constant_pool_count` | `1`                       |
| `cp_info`        | `constant_pool`       | `constant_pool_count - 1` |
| `u2`             | `access_flags`        | `1`                       |
| `u2`             | `this_class`          | `1`                       |
| `u2`             | `super_class`         | `1`                       |
| `u2`             | `interfaces_count`    | `1`                       |
| `u2`             | `interfaces`          | `interfaces_count`        |
| `u2`             | `fields_count`        | `1`                       |
| `field_info`     | `fields`              | `fields_count`            |
| `u2`             | `methods_count`       | `1`                       |
| `method_info`    | `methods`             | `methods_count`           |
| `u2`             | `attributes_count`    | `1`                       |
| `attribute_info` | `attributes`          | `attributes_count`        |

对于attribute中的Code没有讲到。

学到这里的读者，我想对你说一句：

```txt
你这个人，好讨厌，居然这么聪明，居然能学到这里；不过，恭喜你，通关了！！！
```

作者有话说：我在写此文的时候，正好在听这首歌，觉得好听，不妨你也听听。《Last Soul on Earth》
