# javac

<!-- TOC -->

- [1. Basic usage](#1-basic-usage)
- [2. How to](#2-how-to)
- [3. Common switches](#3-common-switches)
  - [3.1. classpath and output dir](#31-classpath-and-output-dir)
  - [3.2. debug](#32-debug)
  - [3.3. source and target](#33-source-and-target)
  - [3.4. parameters](#34-parameters)
- [4. javac restriction](#4-javac-restriction)
  - [4.1. Ant Solution](#41-ant-solution)
  - [4.2. Maven Solution](#42-maven-solution)

<!-- /TOC -->

`javac` is the **Java source code compiler**—it produces **bytecode** (in the form of `.class` files) from `.java` **source files**.

## 1. Basic usage

```bash
javac some/package/MyClass.java
```

过去，我经常使用`javac Hello.java`；今天突然遇到`javac *.java`，原来也可以这么用啊。

```bash
javac *.java
```

- 优点在于，不用指定特定的Java文件名
- 缺点在于，这些Java文件必须位于同一个目录下

## 2. How to

- **How to** compile a single source file:

```bash
javac YourSourceFile.java
```

- **How to** compile multiple source files by name

```bash
javac FileOne.java FileTwo.java FileThree.java
```

- **How to** compile multiple source files using **wildcards** - if you have all of the source files for a single program in the same directory you can compile them all with a single command without having to specify all of their names

```bash
javac *.java
```

- **How to** compile using compiler flags

```bash
javac -Xlint:unchecked SourceFile.java
```

- How to compile all java files under a given directory recursively

If you need to try something out for a larger project and don't have any proper build tools nearby, you can always use a small trick that `javac` offers: the **classnames** to compile can be specified in a file. You simply have to pass the name of the file to `javac` with the `@` prefix.

If you can create a list of all the `*.java` files in your project, it's easy:

```bash
# Linux / MacOS
$ find -name "*.java" > sources.txt
$ javac @sources.txt
## 添加classpath的情况
$ javac -classpath "${CLASSPATH}" @java_sources.txt
```

```cmd
:: Windows
> dir /s /B *.java > sources.txt
> javac @sources.txt
```

**The advantage** is that is is a quick and easy solution.

**The drawback** is that you have to regenerate the `sources.txt` file each time you create a new source or rename an existing one file which is an easy to forget (thus error-prone) and tiresome task.

## 3. Common switches

### 3.1. classpath and output dir

- `-classpath`: Supplies classes we need for compilation.
- `-d some/dir`: Tells `javac` where to output class files.

### 3.2. debug

- `-g`: Generate all debugging info
- `-g:none`: Generate no debugging info
- `-g:{lines,vars,source}`: Generate only some debugging info

查看Byte Code的时候，我喜欢使用`-g:vars`参数：

```bash
javac -g:vars Main.java
javac -g:vars,lines Main.java
```

- `-profile <profile>`: Control the profile that javac will use when compiling the application.

### 3.3. source and target

source and target

- `-source <version>`: Control the Java version that javac will accept.
- `-target <version>`: Control the version of class files that javac will output.

`javac` has traditionally accepted switches (`-source` and `-target`) that control **the version of the source language** that the compiler would accept, and **the version of the class file format** that was used for the outputted class files.

From JDK 8 onward, javac will only accept **source** and **target** options from **three versions back**. That is, only the formats from JDK 5, 6, 7, and 8 will be accepted by `javac`. This does not affect the **java interpreter**—any class file from any Java version will still work on the JVM shipped with Java 8.

### 3.4. parameters

- `-parameters`: Stores formal parameter names of constructors and methods in the generated class file so that the method `java.lang.reflect.Executable.getParameters` from the Reflection API can retrieve them.

```bash
javac -parameters Main.java
```

在`.class`文件中，为了生成Method的`MethodParameters`属性，需要满足这两个条件：

- （1）在使用javac时，使用`-parameters`参数
- （2）方法本身，至少要有一个参数；如果方法没有参数，也不会生成`MethodParameters`属性

## 4. javac restriction

When `javac` is compiling code it doesn't link against `rt.jar` by default. Instead it uses special symbol file `JAVA_HOME/lib/ct.sym` with class stubs. Surprisingly this file contains many but not all of internal `sun` classes. The option `-XDignore.symbol.file` is to ignore the **symbol file** so that it will link against `rt.jar`.

And the answer to my question is: `javac -XDignore.symbol.file`

### 4.1. Ant Solution

```xml
<target name="compile" depends="init" description="Compiles the source code">
    <javac srcdir="${src}" destdir="${build.class}">
        <compilerarg value="-XDignore.symbol.file"/>
    </javac>
</target>
```

### 4.2. Maven Solution

If you're using Maven, note that the compiler plugin will silently drop any `-XD` flags, unless you also specify `<fork>true</fork>`:

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.3</version>
            <configuration>
                <source>1.8</source>
                <target>1.8</target>
                <compilerArgs>
                    <arg>-XDignore.symbol.file</arg>
                </compilerArgs>
                <fork>true</fork>
            </configuration>
```
