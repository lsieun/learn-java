# Method

<!-- TOC -->

- [1. Get Method](#1-get-method)
  - [1.1. List Method](#11-list-method)
  - [1.2. Get One Method](#12-get-one-method)
- [2. Method Parameter](#2-method-parameter)
  - [2.1. Method Parameter Type](#21-method-parameter-type)
  - [2.2. Method Parameter Names](#22-method-parameter-names)
- [3. Method Return Type](#3-method-return-type)
- [4. Invoke Method](#4-invoke-method)

<!-- /TOC -->

## 1. Get Method

### 1.1. List Method

方法对比

|                        | c_1  | c_2  | c_4  | s_1  | s_2  | s_4  | i_1  | i_2  | i_3  |
| ---------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| `getMethods()`         | OK   |      |      | OK   |      |      | OK   | OK   |      |
| `getDeclaredMethods()` | OK   | OK   | OK   |      |      |      |      |      |      |

其中，

- `c_1`，表示child public方法
- `c_2`，表示child private方法
- `c_4`，表示child protected方法
- `s_1`，表示super public方法
- `s_2`，表示super private方法
- `s_4`，表示super protected方法
- `i_1`，表示interface public方法
- `i_2`，表示interface default方法
- `i_3`，表示interface static方法

### 1.2. Get One Method

```java
final Method method = clazz.getDeclaredMethod(methodName, parameterTypes);
```

## 2. Method Parameter

### 2.1. Method Parameter Type

```java
private static final String FORMAT = "%s: %s";

public static void main(String[] args) {
    Class<?> clazz = Example.class;
    Method[] methods = clazz.getDeclaredMethods();

    for (Method m : methods) {
        Class<?>[] parameterTypes = m.getParameterTypes();
        String line = String.format(FORMAT, m.getName(), Arrays.toString(parameterTypes));
        System.out.println(line);
    }
}
```


### 2.2. Method Parameter Names

The well-known issue which Java developers have been facing for years is the fact that method argument names are not preserved at runtime and were wiped out completely.

> 提出问题：method argument names在runtime期间被擦除。

Several community projects, like for example [Paranamer](https://github.com/paul-hammant/paranamer), tried to solve this issue by injecting some additional metadata into the generated byte code.

> 解决问题：有一些community projects提出了解决方案。

Luckily, **Java 8** changed that by introducing new compiler argument `-parameters` which injects the exact method argument names into the byte code.

> 解决问题：Java 8提出了解决方案

```bash
javac -parameters HelloWorld.java
```

```java
Class<?> clazz = Example.class;
String methodName = "performAction";
Class<?>[] parameterTypes = new Class<?>[]{String.class, Runnable.class};

final Method method = clazz.getDeclaredMethod(methodName, parameterTypes);
Parameter[] parameters = method.getParameters();
for (Parameter p : parameters) {
    System.out.println(p.getName());
}
```

## 3. Method Return Type

```java
Method targetMethod = clazz.getDeclaredMethod(methodName, paramTypes);
Class<?> returnType = targetMethod.getReturnType();
System.out.println(returnType);
```

## 4. Invoke Method

```java
try {
    Method andPrivateMethod = Example.class.getDeclaredMethod("privateAnd", boolean.class, boolean.class);
    andPrivateMethod.setAccessible(true);

    Example instance = new Example();
    Boolean result = (Boolean) andPrivateMethod.invoke(instance, true, false);
    System.out.println("true && false == " + result);
} catch (Exception e) {
    e.printStackTrace();
}
```
